diff --git a/src/vs/editor/common/config/editorOptions.ts b/src/vs/editor/common/config/editorOptions.ts
index 4d45c26..8f76a71 100644
--- a/src/vs/editor/common/config/editorOptions.ts
+++ b/src/vs/editor/common/config/editorOptions.ts
@@ -542,7 +542,7 @@ export interface IEditorOptions {
 	 * Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
 	 * Defaults to 'auto'.
 	 */
-	foldingStrategy?: 'auto' | 'indentation';
+	foldingStrategy?: string;
 	/**
 	 * Enable highlight for folded regions.
 	 * Defaults to true.
@@ -553,6 +553,11 @@ export interface IEditorOptions {
 	 * Defaults to 'mouseover'.
 	 */
 	showFoldingControls?: 'always' | 'mouseover';
+	/**
+	 * Show the last line of the folding range.
+	 * Defaults to true.
+	 */
+	showFoldingLastLine?: boolean;
 	/**
 	 * Controls whether clicking on the empty content after a folded line will unfold the line.
 	 * Defaults to false.
@@ -3903,6 +3908,7 @@ export const enum EditorOption {
 	selectionHighlight,
 	selectOnLineNumbers,
 	showFoldingControls,
+	showFoldingLastLine,
 	showUnused,
 	snippetSuggestions,
 	smartSelect,
@@ -4171,16 +4177,10 @@ export const EditorOptions = {
 		EditorOption.folding, 'folding', true,
 		{ description: nls.localize('folding', "Controls whether the editor has code folding enabled.") }
 	)),
-	foldingStrategy: register(new EditorStringEnumOption(
-		EditorOption.foldingStrategy, 'foldingStrategy',
-		'auto' as 'auto' | 'indentation',
-		['auto', 'indentation'] as const,
+	foldingStrategy: register(new EditorStringOption(
+		EditorOption.foldingStrategy, 'foldingStrategy', 'auto',
 		{
-			enumDescriptions: [
-				nls.localize('foldingStrategy.auto', "Use a language-specific folding strategy if available, else the indentation-based one."),
-				nls.localize('foldingStrategy.indentation', "Use the indentation-based folding strategy."),
-			],
-			description: nls.localize('foldingStrategy', "Controls the strategy for computing folding ranges.")
+			description: nls.localize('foldingStrategy', "Controls the strategy for computing folding ranges. `auto`, `indentation` or the custom id of an extension")
 		}
 	)),
 	foldingHighlight: register(new EditorBooleanOption(
@@ -4443,6 +4443,10 @@ export const EditorOptions = {
 			description: nls.localize('showFoldingControls', "Controls when the folding controls on the gutter are shown.")
 		}
 	)),
+	showFoldingLastLine: register(new EditorBooleanOption(
+		EditorOption.showFoldingLastLine, 'showFoldingLastLine', true,
+		{ description: nls.localize('showFoldingLastLine', "Show the last line of the folding range.") }
+	)),
 	showUnused: register(new EditorBooleanOption(
 		EditorOption.showUnused, 'showUnused', true,
 		{ description: nls.localize('showUnused', "Controls fading out of unused code.") }
diff --git a/src/vs/editor/common/modes.ts b/src/vs/editor/common/modes.ts
index f42c4ee..c319451 100644
--- a/src/vs/editor/common/modes.ts
+++ b/src/vs/editor/common/modes.ts
@@ -1441,6 +1441,16 @@ export interface FoldingContext {
  */
 export interface FoldingRangeProvider {
 
+	/**
+	 * Provides the id of the provider.
+	 */
+	readonly id?: string;
+
+	/**
+	 * Flag if the provider is managing the folding range's last line
+	 */
+	readonly isManagingLastLine?: boolean;
+
 	/**
 	 * An optional event to signal that the folding ranges from this provider have changed.
 	 */
diff --git a/src/vs/editor/common/standalone/standaloneEnums.ts b/src/vs/editor/common/standalone/standaloneEnums.ts
index c8389af..5033648 100644
--- a/src/vs/editor/common/standalone/standaloneEnums.ts
+++ b/src/vs/editor/common/standalone/standaloneEnums.ts
@@ -265,6 +265,7 @@ export enum EditorOption {
 	selectionHighlight = 95,
 	selectOnLineNumbers = 96,
 	showFoldingControls = 97,
+	showFoldingLastLine = 999,
 	showUnused = 98,
 	snippetSuggestions = 99,
 	smartSelect = 100,
@@ -841,4 +842,4 @@ export enum WrappingIndent {
 	 * DeepIndent => wrapped lines get +2 indentation toward the parent.
 	 */
 	DeepIndent = 3
-}
\ No newline at end of file
+}
diff --git a/src/vs/editor/contrib/folding/folding.ts b/src/vs/editor/contrib/folding/folding.ts
index de52951..448f669 100644
--- a/src/vs/editor/contrib/folding/folding.ts
+++ b/src/vs/editor/contrib/folding/folding.ts
@@ -25,7 +25,7 @@ import { IRange } from 'vs/editor/common/core/range';
 import { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';
 import { IndentRangeProvider } from 'vs/editor/contrib/folding/indentRangeProvider';
 import { IPosition } from 'vs/editor/common/core/position';
-import { FoldingRangeProviderRegistry, FoldingRangeKind } from 'vs/editor/common/modes';
+import { FoldingRangeProvider, FoldingRangeProviderRegistry, FoldingRangeKind } from 'vs/editor/common/modes';
 import { SyntaxRangeProvider, ID_SYNTAX_PROVIDER } from './syntaxRangeProvider';
 import { CancellationToken } from 'vs/base/common/cancellation';
 import { InitializingRangeProvider, ID_INIT_PROVIDER } from 'vs/editor/contrib/folding/intializingRangeProvider';
@@ -34,6 +34,8 @@ import { onUnexpectedError } from 'vs/base/common/errors';
 import { RawContextKey, IContextKey, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
 import { registerThemingParticipant, ThemeIcon } from 'vs/platform/theme/common/themeService';
 import { registerColor, editorSelectionBackground, transparent, iconForeground } from 'vs/platform/theme/common/colorRegistry';
+import { NoopRangeProvider } from 'vs/editor/contrib/folding/noopRangeProvider';
+import { IndentFoldingProvider } from 'vs/editor/contrib/folding/indentFoldingProvider';
 
 const CONTEXT_FOLDING_ENABLED = new RawContextKey<boolean>('foldingEnabled', false);
 
@@ -49,6 +51,11 @@ interface FoldingStateMemento {
 	provider?: string;
 }
 
+enum StrategyMode {
+	AND,
+	OR,
+}
+
 export class FoldingController extends Disposable implements IEditorContribution {
 
 	public static readonly ID = 'editor.contrib.folding';
@@ -61,7 +68,6 @@ export class FoldingController extends Disposable implements IEditorContribution
 
 	private readonly editor: ICodeEditor;
 	private _isEnabled: boolean;
-	private _useFoldingProviders: boolean;
 	private _unfoldOnClickAfterEndOfLine: boolean;
 	private _restoringViewState: boolean;
 
@@ -84,6 +90,10 @@ export class FoldingController extends Disposable implements IEditorContribution
 	private readonly localToDispose = this._register(new DisposableStore());
 	private mouseDownInfo: { lineNumber: number, iconClicked: boolean } | null;
 
+	private strategyMode: StrategyMode = 0;
+	private strategyProviderIds: string[] = [];
+	private showFoldingLastLine: boolean = false;
+
 	constructor(
 		editor: ICodeEditor,
 		@IContextKeyService private readonly contextKeyService: IContextKeyService
@@ -92,7 +102,8 @@ export class FoldingController extends Disposable implements IEditorContribution
 		this.editor = editor;
 		const options = this.editor.getOptions();
 		this._isEnabled = options.get(EditorOption.folding);
-		this._useFoldingProviders = options.get(EditorOption.foldingStrategy) !== 'indentation';
+		this.setStrategy(options.get(EditorOption.foldingStrategy));
+		this.showFoldingLastLine = options.get(EditorOption.showFoldingLastLine);
 		this._unfoldOnClickAfterEndOfLine = options.get(EditorOption.unfoldOnClickAfterEndOfLine);
 		this._restoringViewState = false;
 
@@ -115,23 +126,28 @@ export class FoldingController extends Disposable implements IEditorContribution
 		this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
 
 		this._register(this.editor.onDidChangeConfiguration((e: ConfigurationChangedEvent) => {
+			const options = this.editor.getOptions();
+
 			if (e.hasChanged(EditorOption.folding)) {
-				this._isEnabled = this.editor.getOptions().get(EditorOption.folding);
+				this._isEnabled = options.get(EditorOption.folding);
 				this.foldingEnabled.set(this._isEnabled);
 				this.onModelChanged();
 			}
 			if (e.hasChanged(EditorOption.showFoldingControls) || e.hasChanged(EditorOption.foldingHighlight)) {
-				const options = this.editor.getOptions();
 				this.foldingDecorationProvider.autoHideFoldingControls = options.get(EditorOption.showFoldingControls) === 'mouseover';
 				this.foldingDecorationProvider.showFoldingHighlights = options.get(EditorOption.foldingHighlight);
 				this.onModelContentChanged();
 			}
 			if (e.hasChanged(EditorOption.foldingStrategy)) {
-				this._useFoldingProviders = this.editor.getOptions().get(EditorOption.foldingStrategy) !== 'indentation';
+				this.setStrategy(options.get(EditorOption.foldingStrategy))
+				this.onFoldingStrategyChanged();
+			}
+			if (e.hasChanged(EditorOption.showFoldingLastLine)) {
+				this.showFoldingLastLine = options.get(EditorOption.showFoldingLastLine);
 				this.onFoldingStrategyChanged();
 			}
 			if (e.hasChanged(EditorOption.unfoldOnClickAfterEndOfLine)) {
-				this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(EditorOption.unfoldOnClickAfterEndOfLine);
+				this._unfoldOnClickAfterEndOfLine = options.get(EditorOption.unfoldOnClickAfterEndOfLine);
 			}
 		}));
 		this.onModelChanged();
@@ -251,26 +267,114 @@ export class FoldingController extends Disposable implements IEditorContribution
 		if (this.rangeProvider) {
 			return this.rangeProvider;
 		}
-		this.rangeProvider = new IndentRangeProvider(editorModel); // fallback
+		this.rangeProvider = new NoopRangeProvider(); // fallback
 
+		if (this.foldingModel) {
+			if (this.strategyMode === StrategyMode.AND) {
+				const foldingProviders: Array<FoldingRangeProvider> = [];
+
+				for (const id of this.strategyProviderIds) {
+					if (id === 'language') {
+						const providers = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel).filter(provider => provider.id === null);
+
+						if (providers.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
+							return this.createInitializingRangeProvider(editorModel);
+						} else {
+							foldingProviders.push(...providers);
+						}
+					} else if (id === 'indentation') {
+						foldingProviders.push(new IndentFoldingProvider());
+					} else {
+						const providers = FoldingRangeProviderRegistry.ordered(editorModel).filter(provider => provider.id === id);
+						foldingProviders.push(...providers);
+					}
+				}
 
-		if (this._useFoldingProviders && this.foldingModel) {
-			let foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);
-			if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
-				const rangeProvider = this.rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, () => {
-					// if after 30 the InitializingRangeProvider is still not replaced, force a refresh
-					this.foldingStateMemento = null;
-					this.onFoldingStrategyChanged();
-				}, 30000);
-				return rangeProvider; // keep memento in case there are still no foldingProviders on the next request.
-			} else if (foldingProviders.length > 0) {
-				this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, () => this.onModelContentChanged());
+				this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, this.showFoldingLastLine, () => this.onModelContentChanged());
+			} else {
+				for (const id of this.strategyProviderIds) {
+					if (id === 'language') {
+						const providers = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel).filter(provider => provider.id === null);
+
+						if (providers.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
+							return this.createInitializingRangeProvider(editorModel);
+						} else if (providers.length > 0) {
+							this.rangeProvider = new SyntaxRangeProvider(editorModel, providers, this.showFoldingLastLine, () => this.onModelContentChanged());
+							break;
+						}
+					} else if (id === 'indentation') {
+						this.rangeProvider = new IndentRangeProvider(editorModel);
+						break;
+					} else {
+						const foldingProviders = FoldingRangeProviderRegistry.ordered(editorModel).filter(provider => provider.id === id);
+
+						if (foldingProviders.length > 0) {
+							this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, this.showFoldingLastLine, () => this.onModelContentChanged());
+							break;
+						}
+					}
+				}
 			}
 		}
+
 		this.foldingStateMemento = null;
 		return this.rangeProvider;
 	}
 
+	private createInitializingRangeProvider(editorModel: ITextModel) {
+		const rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento!.collapsedRegions!, () => {
+			// if after 30s the InitializingRangeProvider is still not replaced, force a refresh
+			this.foldingStateMemento = null;
+			this.onFoldingStrategyChanged();
+		}, 30000);
+
+		this.rangeProvider = rangeProvider;
+
+		return rangeProvider;
+	}
+
+	private setStrategy(strategy: string): void {
+		if (strategy === 'auto') {
+			return this.setDefaultStrategy();
+		}
+
+		const args = strategy.split(/\s*\b\s*/);
+
+		if (args.length === 1) {
+			this.strategyMode = StrategyMode.OR;
+			this.strategyProviderIds = [args[0]]
+			return;
+		}
+
+		const operator = args[1];
+		for (let i = 3; i < args.length; i += 2) {
+			if (args[i] !== operator) {
+				return this.setDefaultStrategy();
+			}
+		}
+
+		if (operator === '&') {
+			this.strategyMode = StrategyMode.AND;
+		} else if (operator === '|') {
+			this.strategyMode = StrategyMode.OR;
+		} else {
+			return this.setDefaultStrategy();
+		}
+
+		this.strategyProviderIds = args.reduce((acc: Array<string>, val: string, index: number) => {
+			if (index % 2 === 0) {
+				acc.push(val);
+			}
+
+			return acc;
+		}, [])
+	}
+
+	private setDefaultStrategy(): void {
+		this.strategyMode = StrategyMode.OR;
+		this.strategyProviderIds = ['language', 'indentation'];
+	}
+
 	public getFoldingModel() {
 		return this.foldingModelPromise;
 	}
diff --git a/src/vs/editor/contrib/folding/indentFoldingProvider.ts b/src/vs/editor/contrib/folding/indentFoldingProvider.ts
new file mode 100644
index 0000000..0a324e0
--- /dev/null
+++ b/src/vs/editor/contrib/folding/indentFoldingProvider.ts
@@ -0,0 +1,15 @@
+import { CancellationToken } from 'vs/base/common/cancellation';
+import { ITextModel } from 'vs/editor/common/model';
+import { FoldingContext, FoldingRange, FoldingRangeProvider, ProviderResult } from 'vs/editor/common/modes';
+import { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';
+import { computeRanges } from 'vs/editor/contrib/folding/indentRangeProvider';
+
+export class IndentFoldingProvider implements FoldingRangeProvider {
+	provideFoldingRanges(model: ITextModel, context: FoldingContext, token: CancellationToken): ProviderResult<FoldingRange[]> {
+		let foldingRules = LanguageConfigurationRegistry.getFoldingRules(model.getLanguageIdentifier().id);
+		let offSide = foldingRules && !!foldingRules.offSide;
+		let markers = foldingRules && foldingRules.markers;
+
+		return Promise.resolve(computeRanges(model, offSide, markers).toFoldingRanges(model));
+	}
+}
diff --git a/src/vs/editor/contrib/folding/indentRangeProvider.ts b/src/vs/editor/contrib/folding/indentRangeProvider.ts
index da1c2bc..e452e54 100644
--- a/src/vs/editor/contrib/folding/indentRangeProvider.ts
+++ b/src/vs/editor/contrib/folding/indentRangeProvider.ts
@@ -10,6 +10,7 @@ import { TextModel } from 'vs/editor/common/model/textModel';
 import { RangeProvider } from './folding';
 import { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';
 import { CancellationToken } from 'vs/base/common/cancellation';
+import { FoldingRange, FoldingRangeKind } from 'vs/editor/common/modes';
 
 const MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;
 
@@ -28,7 +29,7 @@ export class IndentRangeProvider implements RangeProvider {
 		let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);
 		let offSide = foldingRules && !!foldingRules.offSide;
 		let markers = foldingRules && foldingRules.markers;
-		return Promise.resolve(computeRanges(this.editorModel, offSide, markers));
+		return Promise.resolve(computeRanges(this.editorModel, offSide, markers).toFoldingRegions(this.editorModel));
 	}
 }
 
@@ -61,7 +62,43 @@ export class RangesCollector {
 		}
 	}
 
-	public toIndentRanges(model: ITextModel) {
+	public toFoldingRanges(model: ITextModel) {
+		const foldingRanges: FoldingRange[] = [];
+
+		if (this._length <= this._foldingRangesLimit) {
+			// reverse and create arrays of the exact length
+			for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
+				foldingRanges.push({ start: this._startIndexes[i], end: this._endIndexes[i], kind: FoldingRangeKind.Region });
+			}
+		} else {
+			let entries = 0;
+			let maxIndent = this._indentOccurrences.length;
+			for (let i = 0; i < this._indentOccurrences.length; i++) {
+				let n = this._indentOccurrences[i];
+				if (n) {
+					if (n + entries > this._foldingRangesLimit) {
+						maxIndent = i;
+						break;
+					}
+					entries += n;
+				}
+			}
+			const tabSize = model.getOptions().tabSize;
+			// reverse and create arrays of the exact length
+			for (let i = this._length - 1; i >= 0; i--) {
+				let startIndex = this._startIndexes[i];
+				let lineContent = model.getLineContent(startIndex);
+				let indent = TextModel.computeIndentLevel(lineContent, tabSize);
+				if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {
+					foldingRanges.push({ start: startIndex, end: this._endIndexes[i], kind: FoldingRangeKind.Region });
+				}
+			}
+		}
+
+		return foldingRanges;
+	}
+
+	public toFoldingRegions(model: ITextModel) {
 		if (this._length <= this._foldingRangesLimit) {
 			// reverse and create arrays of the exact length
 			let startIndexes = new Uint32Array(this._length);
@@ -111,7 +148,7 @@ interface PreviousRegion {
 	line: number; // start line of the region. Only used for marker regions.
 }
 
-export function computeRanges(model: ITextModel, offSide: boolean, markers?: FoldingMarkers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT): FoldingRegions {
+export function computeRanges(model: ITextModel, offSide: boolean, markers?: FoldingMarkers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT): RangesCollector {
 	const tabSize = model.getOptions().tabSize;
 	let result = new RangesCollector(foldingRangesLimit);
 
@@ -184,5 +221,5 @@ export function computeRanges(model: ITextModel, offSide: boolean, markers?: Fol
 			previousRegions.push({ indent, endAbove: line, line });
 		}
 	}
-	return result.toIndentRanges(model);
+	return result;
 }
diff --git a/src/vs/editor/contrib/folding/noopRangeProvider.ts b/src/vs/editor/contrib/folding/noopRangeProvider.ts
new file mode 100644
index 0000000..6a99b20
--- /dev/null
+++ b/src/vs/editor/contrib/folding/noopRangeProvider.ts
@@ -0,0 +1,19 @@
+import { FoldingRegions } from 'vs/editor/contrib/folding/foldingRanges';
+import { RangeProvider } from './folding';
+import { CancellationToken } from 'vs/base/common/cancellation';
+
+export const ID_NOOP_PROVIDER = 'noop';
+
+export class NoopRangeProvider implements RangeProvider {
+	readonly id = ID_NOOP_PROVIDER;
+
+	constructor() {
+	}
+
+	dispose() {
+	}
+
+	compute(cancelationToken: CancellationToken): Promise<FoldingRegions> {
+		return Promise.resolve(new FoldingRegions(new Uint32Array(0), new Uint32Array(0)));
+	}
+}
diff --git a/src/vs/editor/contrib/folding/syntaxRangeProvider.ts b/src/vs/editor/contrib/folding/syntaxRangeProvider.ts
index 898694b..f58855e 100644
--- a/src/vs/editor/contrib/folding/syntaxRangeProvider.ts
+++ b/src/vs/editor/contrib/folding/syntaxRangeProvider.ts
@@ -28,7 +28,7 @@ export class SyntaxRangeProvider implements RangeProvider {
 
 	readonly disposables: DisposableStore | undefined;
 
-	constructor(private readonly editorModel: ITextModel, private providers: FoldingRangeProvider[], handleFoldingRangesChange: () => void, private limit = MAX_FOLDING_REGIONS) {
+	constructor(private readonly editorModel: ITextModel, private providers: FoldingRangeProvider[], private showFoldingLastLine: boolean, handleFoldingRangesChange: () => void, private limit = MAX_FOLDING_REGIONS) {
 		for (const provider of providers) {
 			if (typeof provider.onDidChange === 'function') {
 				if (!this.disposables) {
@@ -40,7 +40,7 @@ export class SyntaxRangeProvider implements RangeProvider {
 	}
 
 	compute(cancellationToken: CancellationToken): Promise<FoldingRegions | null> {
-		return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {
+		return collectSyntaxRanges(this.providers, this.editorModel, this.showFoldingLastLine, cancellationToken).then(ranges => {
 			if (ranges) {
 				let res = sanitizeRanges(ranges, this.limit);
 				return res;
@@ -54,7 +54,7 @@ export class SyntaxRangeProvider implements RangeProvider {
 	}
 }
 
-function collectSyntaxRanges(providers: FoldingRangeProvider[], model: ITextModel, cancellationToken: CancellationToken): Promise<IFoldingRangeData[] | null> {
+function collectSyntaxRanges(providers: FoldingRangeProvider[], model: ITextModel, showFoldingLastLine: boolean, cancellationToken: CancellationToken): Promise<IFoldingRangeData[] | null> {
 	let rangeData: IFoldingRangeData[] | null = null;
 	let promises = providers.map((provider, i) => {
 		return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {
@@ -65,10 +65,23 @@ function collectSyntaxRanges(providers: FoldingRangeProvider[], model: ITextMode
 				if (!Array.isArray(rangeData)) {
 					rangeData = [];
 				}
+
 				let nLines = model.getLineCount();
-				for (let r of ranges) {
-					if (r.start > 0 && r.end > r.start && r.end <= nLines) {
-						rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
+				if (provider.isManagingLastLine || showFoldingLastLine) {
+					for (let r of ranges) {
+						if (r.start > 0 && r.end > r.start && r.end <= nLines) {
+							rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
+						}
+					}
+				} else {
+					for (let r of ranges) {
+						if (r.start > 0 && r.end >= r.start && r.end <= nLines) {
+							if (r.end === nLines) {
+								rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
+							} else {
+								rangeData.push({ start: r.start, end: r.end + 1, rank: i, kind: r.kind });
+							}
+						}
 					}
 				}
 			}
diff --git a/src/vs/editor/contrib/folding/test/foldingModel.test.ts b/src/vs/editor/contrib/folding/test/foldingModel.test.ts
index fb82759..e8cf0d1 100644
--- a/src/vs/editor/contrib/folding/test/foldingModel.test.ts
+++ b/src/vs/editor/contrib/folding/test/foldingModel.test.ts
@@ -145,7 +145,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -184,7 +184,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -230,7 +230,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -242,7 +242,7 @@ suite('Folding Model', () => {
 
 			textModel.applyEdits([EditOperation.insert(new Position(4, 1), '//hello\n')]);
 
-			foldingModel.update(computeRanges(textModel, false, undefined));
+			foldingModel.update(computeRanges(textModel, false, undefined).toFoldingRegions(textModel));
 
 			assertRanges(foldingModel, [r(1, 3, true), r(5, 8, false), r(6, 7, true)]);
 		} finally {
@@ -270,7 +270,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 12, false);
@@ -284,7 +284,7 @@ suite('Folding Model', () => {
 
 			textModel.applyEdits([EditOperation.delete(new Range(6, 11, 9, 0))]);
 
-			foldingModel.update(computeRanges(textModel, false, undefined));
+			foldingModel.update(computeRanges(textModel, false, undefined).toFoldingRegions(textModel));
 
 			assertRanges(foldingModel, [r(1, 9, false), r(2, 8, false), r(3, 5, false), r(6, 8, false)]);
 		} finally {
@@ -307,7 +307,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -349,7 +349,7 @@ suite('Folding Model', () => {
 
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -399,7 +399,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 10, false);
@@ -445,7 +445,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -501,7 +501,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\s*\/\/#region$/, end: /^\s*\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\s*\/\/#region$/, end: /^\s*\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -557,7 +557,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -609,7 +609,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -656,7 +656,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -701,7 +701,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -741,7 +741,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -784,7 +784,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 6, false);
diff --git a/src/vs/editor/contrib/folding/test/foldingRanges.test.ts b/src/vs/editor/contrib/folding/test/foldingRanges.test.ts
index d656202..b3a1c4b 100644
--- a/src/vs/editor/contrib/folding/test/foldingRanges.test.ts
+++ b/src/vs/editor/contrib/folding/test/foldingRanges.test.ts
@@ -27,7 +27,7 @@ suite('FoldingRanges', () => {
 			lines.push('#endregion');
 		}
 		let model = createTextModel(lines.join('\n'));
-		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS);
+		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS).toFoldingRegions(model);
 		assert.strictEqual(actual.length, nRegions, 'len');
 		for (let i = 0; i < nRegions; i++) {
 			assert.strictEqual(actual.getStartLineNumber(i), i + 1, 'start' + i);
@@ -55,7 +55,7 @@ suite('FoldingRanges', () => {
 
 		let textModel = createTextModel(lines.join('\n'));
 		try {
-			let actual = computeRanges(textModel, false, markers);
+			let actual = computeRanges(textModel, false, markers).toFoldingRegions(textModel);
 			// let r0 = r(1, 2);
 			// let r1 = r(3, 12);
 			// let r2 = r(4, 11);
@@ -92,7 +92,7 @@ suite('FoldingRanges', () => {
 			lines.push('#endregion');
 		}
 		let model = createTextModel(lines.join('\n'));
-		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS);
+		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS).toFoldingRegions(model);
 		assert.strictEqual(actual.length, nRegions, 'len');
 		for (let i = 0; i < nRegions; i++) {
 			actual.setCollapsed(i, i % 3 === 0);
diff --git a/src/vs/editor/contrib/folding/test/hiddenRangeModel.test.ts b/src/vs/editor/contrib/folding/test/hiddenRangeModel.test.ts
index 7a3f524..db4ecc8 100644
--- a/src/vs/editor/contrib/folding/test/hiddenRangeModel.test.ts
+++ b/src/vs/editor/contrib/folding/test/hiddenRangeModel.test.ts
@@ -44,7 +44,7 @@ suite('Hidden Range Model', () => {
 
 		assert.strictEqual(hiddenRangeModel.hasRanges(), false);
 
-		let ranges = computeRanges(textModel, false, undefined);
+		let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 		foldingModel.update(ranges);
 
 		foldingModel.toggleCollapseState([foldingModel.getRegionAtLine(1)!, foldingModel.getRegionAtLine(6)!]);
diff --git a/src/vs/editor/contrib/folding/test/indentFold.test.ts b/src/vs/editor/contrib/folding/test/indentFold.test.ts
index 76f3399..5605106 100644
--- a/src/vs/editor/contrib/folding/test/indentFold.test.ts
+++ b/src/vs/editor/contrib/folding/test/indentFold.test.ts
@@ -50,7 +50,7 @@ suite('Indentation Folding', () => {
 		let model = createTextModel(lines.join('\n'));
 
 		function assertLimit(maxEntries: number, expectedRanges: IndentRange[], message: string) {
-			let indentRanges = computeRanges(model, true, undefined, maxEntries);
+			let indentRanges = computeRanges(model, true, undefined, maxEntries).toFoldingRegions(model);
 			assert.ok(indentRanges.length <= maxEntries, 'max ' + message);
 			let actual: IndentRange[] = [];
 			for (let i = 0; i < indentRanges.length; i++) {
diff --git a/src/vs/editor/contrib/folding/test/indentRangeProvider.test.ts b/src/vs/editor/contrib/folding/test/indentRangeProvider.test.ts
index 58fa7ab..1b25ad7 100644
--- a/src/vs/editor/contrib/folding/test/indentRangeProvider.test.ts
+++ b/src/vs/editor/contrib/folding/test/indentRangeProvider.test.ts
@@ -16,7 +16,7 @@ interface ExpectedIndentRange {
 
 function assertRanges(lines: string[], expected: ExpectedIndentRange[], offside: boolean, markers?: FoldingMarkers): void {
 	let model = createTextModel(lines.join('\n'));
-	let actual = computeRanges(model, offside, markers);
+	let actual = computeRanges(model, offside, markers).toFoldingRegions(model);
 
 	let actualRanges: ExpectedIndentRange[] = [];
 	for (let i = 0; i < actual.length; i++) {
diff --git a/src/vs/editor/contrib/folding/test/syntaxFold.test.ts b/src/vs/editor/contrib/folding/test/syntaxFold.test.ts
index c416210..12d19dd 100644
--- a/src/vs/editor/contrib/folding/test/syntaxFold.test.ts
+++ b/src/vs/editor/contrib/folding/test/syntaxFold.test.ts
@@ -74,7 +74,7 @@ suite('Syntax folding', () => {
 		let providers = [new TestFoldingRangeProvider(model, ranges)];
 
 		async function assertLimit(maxEntries: number, expectedRanges: IndentRange[], message: string) {
-			let indentRanges = await new SyntaxRangeProvider(model, providers, () => { }, maxEntries).compute(CancellationToken.None);
+			let indentRanges = await new SyntaxRangeProvider(model, providers, true, () => { }, maxEntries).compute(CancellationToken.None);
 			let actual: IndentRange[] = [];
 			if (indentRanges) {
 				for (let i = 0; i < indentRanges.length; i++) {
diff --git a/src/vs/monaco.d.ts b/src/vs/monaco.d.ts
index 0958d5b..d2a7e21 100644
--- a/src/vs/monaco.d.ts
+++ b/src/vs/monaco.d.ts
@@ -3133,7 +3133,7 @@ declare namespace monaco.editor {
 		 * Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
 		 * Defaults to 'auto'.
 		 */
-		foldingStrategy?: 'auto' | 'indentation';
+		foldingStrategy?: string;
 		/**
 		 * Enable highlight for folded regions.
 		 * Defaults to true.
@@ -3144,6 +3144,11 @@ declare namespace monaco.editor {
 		 * Defaults to 'mouseover'.
 		 */
 		showFoldingControls?: 'always' | 'mouseover';
+		/**
+		 * Show the last line of the folding range.
+		 * Defaults to true.
+		 */
+		showFoldingLastLine?: boolean;
 		/**
 		 * Controls whether clicking on the empty content after a folded line will unfold the line.
 		 * Defaults to false.
@@ -4112,6 +4117,7 @@ declare namespace monaco.editor {
 		selectionHighlight = 95,
 		selectOnLineNumbers = 96,
 		showFoldingControls = 97,
+		showFoldingLastLine = 999,
 		showUnused = 98,
 		snippetSuggestions = 99,
 		smartSelect = 100,
@@ -4183,7 +4189,7 @@ declare namespace monaco.editor {
 		find: IEditorOption<EditorOption.find, EditorFindOptions>;
 		fixedOverflowWidgets: IEditorOption<EditorOption.fixedOverflowWidgets, boolean>;
 		folding: IEditorOption<EditorOption.folding, boolean>;
-		foldingStrategy: IEditorOption<EditorOption.foldingStrategy, 'auto' | 'indentation'>;
+		foldingStrategy: IEditorOption<EditorOption.foldingStrategy, string>;
 		foldingHighlight: IEditorOption<EditorOption.foldingHighlight, boolean>;
 		unfoldOnClickAfterEndOfLine: IEditorOption<EditorOption.unfoldOnClickAfterEndOfLine, boolean>;
 		fontFamily: IEditorOption<EditorOption.fontFamily, string>;
@@ -4244,6 +4250,7 @@ declare namespace monaco.editor {
 		selectionHighlight: IEditorOption<EditorOption.selectionHighlight, boolean>;
 		selectOnLineNumbers: IEditorOption<EditorOption.selectOnLineNumbers, boolean>;
 		showFoldingControls: IEditorOption<EditorOption.showFoldingControls, 'always' | 'mouseover'>;
+		showFoldingLastLine: IEditorOption<EditorOption.showFoldingLastLine, boolean>;
 		showUnused: IEditorOption<EditorOption.showUnused, boolean>;
 		showDeprecated: IEditorOption<EditorOption.showDeprecated, boolean>;
 		inlayHints: IEditorOption<EditorOption.inlayHints, any>;
@@ -6420,6 +6427,14 @@ declare namespace monaco.languages {
 	 * A provider of folding ranges for editor models.
 	 */
 	export interface FoldingRangeProvider {
+		/**
+		 * Provides the id of the provider.
+		 */
+		readonly id?: string;
+		/**
+		 * Flag if the provider is managing the folding range's last line
+		 */
+		readonly isManagingLastLine?: boolean;
 		/**
 		 * An optional event to signal that the folding ranges from this provider have changed.
 		 */
diff --git a/src/vs/vscode.d.ts b/src/vs/vscode.d.ts
index 77b7c54..fd3c3f7 100644
--- a/src/vs/vscode.d.ts
+++ b/src/vs/vscode.d.ts
@@ -4533,6 +4533,16 @@ declare module 'vscode' {
 	 */
 	export interface FoldingRangeProvider {
 
+		/**
+		 * Provides the id of the provider.
+		 */
+		readonly id?: string;
+
+		/**
+		 * Flag if the provider is managing the folding range's last line
+		 */
+		readonly isManagingLastLine?: boolean;
+
 		/**
 		 * An optional event to signal that the folding ranges from this provider have changed.
 		 */
diff --git a/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts b/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts
index 16a59ac..ed590cd 100644
--- a/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts
+++ b/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts
@@ -633,8 +633,10 @@ export class MainThreadLanguageFeatures implements MainThreadLanguageFeaturesSha
 
 	// --- folding
 
-	$registerFoldingRangeProvider(handle: number, selector: IDocumentFilterDto[], eventHandle: number | undefined): void {
+	$registerFoldingRangeProvider(handle: number, id: string | null, isManagingLastLine: boolean, selector: IDocumentFilterDto[], eventHandle: number | undefined): void {
 		const provider = <modes.FoldingRangeProvider>{
+			id,
+			isManagingLastLine,
 			provideFoldingRanges: (model, context, token) => {
 				return this._proxy.$provideFoldingRanges(handle, model.uri, context, token);
 			}
diff --git a/src/vs/workbench/api/common/extHost.protocol.ts b/src/vs/workbench/api/common/extHost.protocol.ts
index a6bd90d..f771ae4 100644
--- a/src/vs/workbench/api/common/extHost.protocol.ts
+++ b/src/vs/workbench/api/common/extHost.protocol.ts
@@ -407,7 +407,7 @@ export interface MainThreadLanguageFeaturesShape extends IDisposable {
 	$emitInlayHintsEvent(eventHandle: number, event?: any): void;
 	$registerDocumentLinkProvider(handle: number, selector: IDocumentFilterDto[], supportsResolve: boolean): void;
 	$registerDocumentColorProvider(handle: number, selector: IDocumentFilterDto[]): void;
-	$registerFoldingRangeProvider(handle: number, selector: IDocumentFilterDto[], eventHandle: number | undefined): void;
+	$registerFoldingRangeProvider(handle: number, id: string | null, isManagingLastLine: boolean, selector: IDocumentFilterDto[], eventHandle: number | undefined): void;
 	$emitFoldingRangeEvent(eventHandle: number, event?: any): void;
 	$registerSelectionRangeProvider(handle: number, selector: IDocumentFilterDto[]): void;
 	$registerCallHierarchyProvider(handle: number, selector: IDocumentFilterDto[]): void;
diff --git a/src/vs/workbench/api/common/extHostLanguageFeatures.ts b/src/vs/workbench/api/common/extHostLanguageFeatures.ts
index 05ab94c..748ec67 100644
--- a/src/vs/workbench/api/common/extHostLanguageFeatures.ts
+++ b/src/vs/workbench/api/common/extHostLanguageFeatures.ts
@@ -2005,7 +2005,7 @@ export class ExtHostLanguageFeatures implements extHostProtocol.ExtHostLanguageF
 		const eventHandle = typeof provider.onDidChangeFoldingRanges === 'function' ? this._nextHandle() : undefined;
 
 		this._adapter.set(handle, new AdapterData(new FoldingProviderAdapter(this._documents, provider), extension));
-		this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector), eventHandle);
+		this._proxy.$registerFoldingRangeProvider(handle, provider.id ?? null, provider.isManagingLastLine ?? false, this._transformDocumentSelector(selector), eventHandle);
 		let result = this._createDisposable(handle);
 
 		if (eventHandle !== undefined) {
