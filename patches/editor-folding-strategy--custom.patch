diff --git a/src/vs/editor/common/config/editorOptions.ts b/src/vs/editor/common/config/editorOptions.ts
index 6a28236..19e6b24 100644
--- a/src/vs/editor/common/config/editorOptions.ts
+++ b/src/vs/editor/common/config/editorOptions.ts
@@ -543,7 +543,7 @@ export interface IEditorOptions {
 	 * Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
 	 * Defaults to 'auto'.
 	 */
-	foldingStrategy?: 'auto' | 'indentation';
+	foldingStrategy?: string;
 	/**
 	 * Enable highlight for folded regions.
 	 * Defaults to true.
@@ -564,6 +564,11 @@ export interface IEditorOptions {
 	 * Defaults to 'mouseover'.
 	 */
 	showFoldingControls?: 'always' | 'mouseover';
+	/**
+	 * Show the last line of the folding range.
+	 * Defaults to true.
+	 */
+	showFoldingLastLine?: boolean;
 	/**
 	 * Controls whether clicking on the empty content after a folded line will unfold the line.
 	 * Defaults to false.
@@ -4402,6 +4407,7 @@ export const enum EditorOption {
 	selectionHighlight,
 	selectOnLineNumbers,
 	showFoldingControls,
+	showFoldingLastLine,
 	showUnused,
 	snippetSuggestions,
 	smartSelect,
@@ -4658,16 +4664,10 @@ export const EditorOptions = {
 		EditorOption.folding, 'folding', true,
 		{ description: nls.localize('folding', "Controls whether the editor has code folding enabled.") }
 	)),
-	foldingStrategy: register(new EditorStringEnumOption(
-		EditorOption.foldingStrategy, 'foldingStrategy',
-		'auto' as 'auto' | 'indentation',
-		['auto', 'indentation'] as const,
+	foldingStrategy: register(new EditorStringOption(
+		EditorOption.foldingStrategy, 'foldingStrategy', 'auto',
 		{
-			enumDescriptions: [
-				nls.localize('foldingStrategy.auto', "Use a language-specific folding strategy if available, else the indentation-based one."),
-				nls.localize('foldingStrategy.indentation', "Use the indentation-based folding strategy."),
-			],
-			description: nls.localize('foldingStrategy', "Controls the strategy for computing folding ranges.")
+			description: nls.localize('foldingStrategy', "Controls the strategy for computing folding ranges. `auto`, `indentation` or the custom id of an extension")
 		}
 	)),
 	foldingHighlight: register(new EditorBooleanOption(
@@ -4931,6 +4931,10 @@ export const EditorOptions = {
 			description: nls.localize('showFoldingControls', "Controls when the folding controls on the gutter are shown.")
 		}
 	)),
+	showFoldingLastLine: register(new EditorBooleanOption(
+		EditorOption.showFoldingLastLine, 'showFoldingLastLine', true,
+		{ description: nls.localize('showFoldingLastLine', "Show the last line of the folding range.") }
+	)),
 	showUnused: register(new EditorBooleanOption(
 		EditorOption.showUnused, 'showUnused', true,
 		{ description: nls.localize('showUnused', "Controls fading out of unused code.") }
diff --git a/src/vs/editor/common/languages.ts b/src/vs/editor/common/languages.ts
index f63fa53..af7efae 100644
--- a/src/vs/editor/common/languages.ts
+++ b/src/vs/editor/common/languages.ts
@@ -1479,6 +1479,16 @@ export interface FoldingContext {
  */
 export interface FoldingRangeProvider {
 
+	/**
+	 * Provides the id of the provider.
+	 */
+	readonly id?: string;
+
+	/**
+	 * Flag if the provider is managing the folding range's last line
+	 */
+	readonly isManagingLastLine?: boolean;
+
 	/**
 	 * An optional event to signal that the folding ranges from this provider have changed.
 	 */
diff --git a/src/vs/editor/common/standalone/standaloneEnums.ts b/src/vs/editor/common/standalone/standaloneEnums.ts
index 8cd71d6..0122bfa 100644
--- a/src/vs/editor/common/standalone/standaloneEnums.ts
+++ b/src/vs/editor/common/standalone/standaloneEnums.ts
@@ -267,39 +267,40 @@ export enum EditorOption {
 	selectionHighlight = 97,
 	selectOnLineNumbers = 98,
 	showFoldingControls = 99,
-	showUnused = 100,
-	snippetSuggestions = 101,
-	smartSelect = 102,
-	smoothScrolling = 103,
-	stickyTabStops = 104,
-	stopRenderingLineAfter = 105,
-	suggest = 106,
-	suggestFontSize = 107,
-	suggestLineHeight = 108,
-	suggestOnTriggerCharacters = 109,
-	suggestSelection = 110,
-	tabCompletion = 111,
-	tabIndex = 112,
-	unicodeHighlighting = 113,
-	unusualLineTerminators = 114,
-	useShadowDOM = 115,
-	useTabStops = 116,
-	wordSeparators = 117,
-	wordWrap = 118,
-	wordWrapBreakAfterCharacters = 119,
-	wordWrapBreakBeforeCharacters = 120,
-	wordWrapColumn = 121,
-	wordWrapOverride1 = 122,
-	wordWrapOverride2 = 123,
-	wrappingIndent = 124,
-	wrappingStrategy = 125,
-	showDeprecated = 126,
-	inlayHints = 127,
-	editorClassName = 128,
-	pixelRatio = 129,
-	tabFocusMode = 130,
-	layoutInfo = 131,
-	wrappingInfo = 132
+	showFoldingLastLine = 100,
+	showUnused = 101,
+	snippetSuggestions = 102,
+	smartSelect = 103,
+	smoothScrolling = 104,
+	stickyTabStops = 105,
+	stopRenderingLineAfter = 106,
+	suggest = 107,
+	suggestFontSize = 108,
+	suggestLineHeight = 109,
+	suggestOnTriggerCharacters = 110,
+	suggestSelection = 111,
+	tabCompletion = 112,
+	tabIndex = 113,
+	unicodeHighlighting = 114,
+	unusualLineTerminators = 115,
+	useShadowDOM = 116,
+	useTabStops = 117,
+	wordSeparators = 118,
+	wordWrap = 119,
+	wordWrapBreakAfterCharacters = 120,
+	wordWrapBreakBeforeCharacters = 121,
+	wordWrapColumn = 122,
+	wordWrapOverride1 = 123,
+	wordWrapOverride2 = 124,
+	wrappingIndent = 125,
+	wrappingStrategy = 126,
+	showDeprecated = 127,
+	inlayHints = 128,
+	editorClassName = 129,
+	pixelRatio = 130,
+	tabFocusMode = 131,
+	layoutInfo = 132,
+	wrappingInfo = 133
 }
 
 /**
diff --git a/src/vs/editor/contrib/folding/browser/folding.ts b/src/vs/editor/contrib/folding/browser/folding.ts
index e626670..eac938a 100644
--- a/src/vs/editor/contrib/folding/browser/folding.ts
+++ b/src/vs/editor/contrib/folding/browser/folding.ts
@@ -21,7 +21,7 @@ import { IEditorContribution, ScrollType } from 'vs/editor/common/editorCommon';
 import { EditorContextKeys } from 'vs/editor/common/editorContextKeys';
 import { ITextModel } from 'vs/editor/common/model';
 import { IModelContentChangedEvent } from 'vs/editor/common/textModelEvents';
-import { FoldingRangeKind, FoldingRangeProviderRegistry } from 'vs/editor/common/languages';
+import { FoldingRangeKind, FoldingRangeProvider, FoldingRangeProviderRegistry } from 'vs/editor/common/languages';
 import { ILanguageConfigurationService } from 'vs/editor/common/languages/languageConfigurationRegistry';
 import { CollapseMemento, FoldingModel, getNextFoldLine, getParentFoldLine as getParentFoldLine, getPreviousFoldLine, setCollapseStateAtLevel, setCollapseStateForMatchingLines, setCollapseStateForRest, setCollapseStateForType, setCollapseStateLevelsDown, setCollapseStateLevelsUp, setCollapseStateUp, toggleCollapseState } from 'vs/editor/contrib/folding/browser/foldingModel';
 import { HiddenRangeModel } from 'vs/editor/contrib/folding/browser/hiddenRangeModel';
@@ -39,6 +39,8 @@ import { INotificationService } from 'vs/platform/notification/common/notificati
 import Severity from 'vs/base/common/severity';
 import { IFeatureDebounceInformation, ILanguageFeatureDebounceService } from 'vs/editor/common/services/languageFeatureDebounce';
 import { StopWatch } from 'vs/base/common/stopwatch';
+import { NoopRangeProvider } from 'vs/editor/contrib/folding/browser/noopRangeProvider';
+import { IndentFoldingProvider } from 'vs/editor/contrib/folding/browser/indentFoldingProvider';
 
 
 const CONTEXT_FOLDING_ENABLED = new RawContextKey<boolean>('foldingEnabled', false);
@@ -56,6 +58,11 @@ interface FoldingStateMemento {
 	foldedImports?: boolean
 }
 
+enum StrategyMode {
+	AND,
+	OR,
+}
+
 export class FoldingController extends Disposable implements IEditorContribution {
 
 	public static readonly ID = 'editor.contrib.folding';
@@ -66,7 +73,6 @@ export class FoldingController extends Disposable implements IEditorContribution
 
 	private readonly editor: ICodeEditor;
 	private _isEnabled: boolean;
-	private _useFoldingProviders: boolean;
 	private _unfoldOnClickAfterEndOfLine: boolean;
 	private _restoringViewState: boolean;
 	private _foldingImportsByDefault: boolean;
@@ -95,6 +101,10 @@ export class FoldingController extends Disposable implements IEditorContribution
 	private readonly localToDispose = this._register(new DisposableStore());
 	private mouseDownInfo: { lineNumber: number, iconClicked: boolean } | null;
 
+	private strategyMode: StrategyMode = 0;
+	private strategyProviderIds: string[] = [];
+	private showFoldingLastLine: boolean = false;
+
 	constructor(
 		editor: ICodeEditor,
 		@IContextKeyService private readonly contextKeyService: IContextKeyService,
@@ -106,7 +116,8 @@ export class FoldingController extends Disposable implements IEditorContribution
 		this.editor = editor;
 		const options = this.editor.getOptions();
 		this._isEnabled = options.get(EditorOption.folding);
-		this._useFoldingProviders = options.get(EditorOption.foldingStrategy) !== 'indentation';
+		this.setStrategy(options.get(EditorOption.foldingStrategy));
+		this.showFoldingLastLine = options.get(EditorOption.showFoldingLastLine);
 		this._unfoldOnClickAfterEndOfLine = options.get(EditorOption.unfoldOnClickAfterEndOfLine);
 		this._restoringViewState = false;
 		this._currentModelHasFoldedImports = false;
@@ -145,6 +156,8 @@ export class FoldingController extends Disposable implements IEditorContribution
 		this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
 
 		this._register(this.editor.onDidChangeConfiguration((e: ConfigurationChangedEvent) => {
+			const options = this.editor.getOptions();
+
 			if (e.hasChanged(EditorOption.folding)) {
 				this._isEnabled = this.editor.getOptions().get(EditorOption.folding);
 				this.foldingEnabled.set(this._isEnabled);
@@ -156,20 +169,23 @@ export class FoldingController extends Disposable implements IEditorContribution
 				this.onModelChanged();
 			}
 			if (e.hasChanged(EditorOption.showFoldingControls) || e.hasChanged(EditorOption.foldingHighlight)) {
-				const options = this.editor.getOptions();
 				this.foldingDecorationProvider.autoHideFoldingControls = options.get(EditorOption.showFoldingControls) === 'mouseover';
 				this.foldingDecorationProvider.showFoldingHighlights = options.get(EditorOption.foldingHighlight);
 				this.triggerFoldingModelChanged();
 			}
 			if (e.hasChanged(EditorOption.foldingStrategy)) {
-				this._useFoldingProviders = this.editor.getOptions().get(EditorOption.foldingStrategy) !== 'indentation';
+				this.setStrategy(options.get(EditorOption.foldingStrategy))
+				this.onFoldingStrategyChanged();
+			}
+			if (e.hasChanged(EditorOption.showFoldingLastLine)) {
+				this.showFoldingLastLine = options.get(EditorOption.showFoldingLastLine);
 				this.onFoldingStrategyChanged();
 			}
 			if (e.hasChanged(EditorOption.unfoldOnClickAfterEndOfLine)) {
-				this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(EditorOption.unfoldOnClickAfterEndOfLine);
+				this._unfoldOnClickAfterEndOfLine = options.get(EditorOption.unfoldOnClickAfterEndOfLine);
 			}
 			if (e.hasChanged(EditorOption.foldingImportsByDefault)) {
-				this._foldingImportsByDefault = this.editor.getOptions().get(EditorOption.foldingImportsByDefault);
+				this._foldingImportsByDefault = options.get(EditorOption.foldingImportsByDefault);
 			}
 		}));
 		this.onModelChanged();
@@ -294,25 +310,114 @@ export class FoldingController extends Disposable implements IEditorContribution
 		if (this.rangeProvider) {
 			return this.rangeProvider;
 		}
-		this.rangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._maxFoldingRegions); // fallback
-
-		if (this._useFoldingProviders && this.foldingModel) {
-			let foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);
-			if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
-				const rangeProvider = this.rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, () => {
-					// if after 30 the InitializingRangeProvider is still not replaced, force a refresh
-					this.foldingStateMemento = null;
-					this.onFoldingStrategyChanged();
-				}, 30000);
-				return rangeProvider; // keep memento in case there are still no foldingProviders on the next request.
-			} else if (foldingProviders.length > 0) {
-				this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions);
+		this.rangeProvider = new NoopRangeProvider(); // fallback
+
+		if (this.foldingModel) {
+			if (this.strategyMode === StrategyMode.AND) {
+				const foldingProviders: Array<FoldingRangeProvider> = [];
+
+				for (const id of this.strategyProviderIds) {
+					if (id === 'language') {
+						const providers = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel).filter(provider => provider.id === null);
+
+						if (providers.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
+							return this.createInitializingRangeProvider(editorModel);
+						} else {
+							foldingProviders.push(...providers);
+						}
+					} else if (id === 'indentation') {
+						foldingProviders.push(new IndentFoldingProvider(this.languageConfigurationService));
+					} else {
+						const providers = FoldingRangeProviderRegistry.ordered(editorModel).filter(provider => provider.id === id);
+						foldingProviders.push(...providers);
+					}
+				}
+
+				this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, this.showFoldingLastLine, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions);
+			} else {
+				for (const id of this.strategyProviderIds) {
+					if (id === 'language') {
+						const providers = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel).filter(provider => provider.id === null);
+
+						if (providers.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
+							return this.createInitializingRangeProvider(editorModel);
+						} else if (providers.length > 0) {
+							this.rangeProvider = new SyntaxRangeProvider(editorModel, providers, this.showFoldingLastLine, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions);
+							break;
+						}
+					} else if (id === 'indentation') {
+						this.rangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._maxFoldingRegions);
+						break;
+					} else {
+						const foldingProviders = FoldingRangeProviderRegistry.ordered(editorModel).filter(provider => provider.id === id);
+
+						if (foldingProviders.length > 0) {
+							this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, this.showFoldingLastLine, () => this.triggerFoldingModelChanged(), this._maxFoldingRegions);
+							break;
+						}
+					}
+				}
 			}
 		}
+
 		this.foldingStateMemento = null;
 		return this.rangeProvider;
 	}
 
+	private createInitializingRangeProvider(editorModel: ITextModel) {
+		const rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento!.collapsedRegions!, () => {
+			// if after 30s the InitializingRangeProvider is still not replaced, force a refresh
+			this.foldingStateMemento = null;
+			this.onFoldingStrategyChanged();
+		}, 30000);
+
+		this.rangeProvider = rangeProvider;
+
+		return rangeProvider;
+	}
+
+	private setStrategy(strategy: string): void {
+		if (strategy === 'auto') {
+			return this.setDefaultStrategy();
+		}
+
+		const args = strategy.split(/\s*\b\s*/);
+
+		if (args.length === 1) {
+			this.strategyMode = StrategyMode.OR;
+			this.strategyProviderIds = [args[0]]
+			return;
+		}
+
+		const operator = args[1];
+		for (let i = 3; i < args.length; i += 2) {
+			if (args[i] !== operator) {
+				return this.setDefaultStrategy();
+			}
+		}
+
+		if (operator === '&') {
+			this.strategyMode = StrategyMode.AND;
+		} else if (operator === '|') {
+			this.strategyMode = StrategyMode.OR;
+		} else {
+			return this.setDefaultStrategy();
+		}
+
+		this.strategyProviderIds = args.reduce((acc: Array<string>, val: string, index: number) => {
+			if (index % 2 === 0) {
+				acc.push(val);
+			}
+
+			return acc;
+		}, [])
+	}
+
+	private setDefaultStrategy(): void {
+		this.strategyMode = StrategyMode.OR;
+		this.strategyProviderIds = ['language', 'indentation'];
+	}
+
 	public getFoldingModel() {
 		return this.foldingModelPromise;
 	}
diff --git a/src/vs/editor/contrib/folding/browser/indentFoldingProvider.ts b/src/vs/editor/contrib/folding/browser/indentFoldingProvider.ts
new file mode 100644
index 0000000..c49a564
--- /dev/null
+++ b/src/vs/editor/contrib/folding/browser/indentFoldingProvider.ts
@@ -0,0 +1,24 @@
+import { CancellationToken } from 'vs/base/common/cancellation';
+import { FoldingContext, FoldingRange, FoldingRangeProvider, ProviderResult } from 'vs/editor/common/languages';
+import { ILanguageConfigurationService } from 'vs/editor/common/languages/languageConfigurationRegistry';
+import { ITextModel } from 'vs/editor/common/model';
+import { computeRanges } from 'vs/editor/contrib/folding/browser/indentRangeProvider';
+
+export class IndentFoldingProvider implements FoldingRangeProvider {
+	public constructor(private readonly languageConfigurationService: ILanguageConfigurationService) {
+	}
+
+	provideFoldingRanges(model: ITextModel, context: FoldingContext, token: CancellationToken): ProviderResult<FoldingRange[]> {
+		const configuration = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId())
+		if (configuration) {
+			const foldingRules = configuration.foldingRules;
+			const offSide = foldingRules && !!foldingRules.offSide;
+			const markers = foldingRules && foldingRules.markers;
+
+			return Promise.resolve(computeRanges(model, offSide, markers).toFoldingRanges(model));
+		}
+		else {
+			return Promise.resolve([]);
+		}
+	}
+}
diff --git a/src/vs/editor/contrib/folding/browser/indentRangeProvider.ts b/src/vs/editor/contrib/folding/browser/indentRangeProvider.ts
index e918367..1f87094 100644
--- a/src/vs/editor/contrib/folding/browser/indentRangeProvider.ts
+++ b/src/vs/editor/contrib/folding/browser/indentRangeProvider.ts
@@ -10,6 +10,7 @@ import { FoldingMarkers } from 'vs/editor/common/languages/languageConfiguration
 import { ILanguageConfigurationService } from 'vs/editor/common/languages/languageConfigurationRegistry';
 import { FoldingRegions, MAX_LINE_NUMBER } from 'vs/editor/contrib/folding/browser/foldingRanges';
 import { RangeProvider } from './folding';
+import { FoldingRange, FoldingRangeKind } from 'vs/editor/common/languages';
 
 const MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;
 
@@ -30,7 +31,7 @@ export class IndentRangeProvider implements RangeProvider {
 		let foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;
 		let offSide = foldingRules && !!foldingRules.offSide;
 		let markers = foldingRules && foldingRules.markers;
-		return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.maxFoldingRegions, notifyTooManyRegions));
+		return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.maxFoldingRegions, notifyTooManyRegions).toFoldingRegions(this.editorModel));
 	}
 }
 
@@ -63,7 +64,43 @@ export class RangesCollector {
 		}
 	}
 
-	public toIndentRanges(model: ITextModel) {
+	public toFoldingRanges(model: ITextModel) {
+		const foldingRanges: FoldingRange[] = [];
+
+		if (this._length <= this._foldingRangesLimit) {
+			// reverse and create arrays of the exact length
+			for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
+				foldingRanges.push({ start: this._startIndexes[i], end: this._endIndexes[i], kind: FoldingRangeKind.Region });
+			}
+		} else {
+			let entries = 0;
+			let maxIndent = this._indentOccurrences.length;
+			for (let i = 0; i < this._indentOccurrences.length; i++) {
+				let n = this._indentOccurrences[i];
+				if (n) {
+					if (n + entries > this._foldingRangesLimit) {
+						maxIndent = i;
+						break;
+					}
+					entries += n;
+				}
+			}
+			const tabSize = model.getOptions().tabSize;
+			// reverse and create arrays of the exact length
+			for (let i = this._length - 1; i >= 0; i--) {
+				let startIndex = this._startIndexes[i];
+				let lineContent = model.getLineContent(startIndex);
+				let indent = computeIndentLevel(lineContent, tabSize);
+				if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {
+					foldingRanges.push({ start: startIndex, end: this._endIndexes[i], kind: FoldingRangeKind.Region });
+				}
+			}
+		}
+
+		return foldingRanges;
+	}
+
+	public toFoldingRegions(model: ITextModel) {
 		if (this._length <= this._foldingRangesLimit) {
 			// reverse and create arrays of the exact length
 			let startIndexes = new Uint32Array(this._length);
@@ -116,7 +153,7 @@ interface PreviousRegion {
 	line: number; // start line of the region. Only used for marker regions.
 }
 
-export function computeRanges(model: ITextModel, offSide: boolean, markers?: FoldingMarkers, foldingRangesLimit?: number, notifyTooManyRegions?: (maxRegions: number) => void): FoldingRegions {
+export function computeRanges(model: ITextModel, offSide: boolean, markers?: FoldingMarkers, foldingRangesLimit?: number, notifyTooManyRegions?: (maxRegions: number) => void): RangesCollector {
 	const tabSize = model.getOptions().tabSize;
 	foldingRangesLimit = foldingRangesLimit ?? MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT;
 	let result = new RangesCollector(foldingRangesLimit, notifyTooManyRegions);
@@ -190,5 +227,5 @@ export function computeRanges(model: ITextModel, offSide: boolean, markers?: Fol
 			previousRegions.push({ indent, endAbove: line, line });
 		}
 	}
-	return result.toIndentRanges(model);
+	return result;
 }
diff --git a/src/vs/editor/contrib/folding/browser/noopRangeProvider.ts b/src/vs/editor/contrib/folding/browser/noopRangeProvider.ts
new file mode 100644
index 0000000..c978ff6
--- /dev/null
+++ b/src/vs/editor/contrib/folding/browser/noopRangeProvider.ts
@@ -0,0 +1,19 @@
+import { RangeProvider } from './folding';
+import { CancellationToken } from 'vs/base/common/cancellation';
+import { FoldingRegions } from 'vs/editor/contrib/folding/browser/foldingRanges';
+
+export const ID_NOOP_PROVIDER = 'noop';
+
+export class NoopRangeProvider implements RangeProvider {
+	readonly id = ID_NOOP_PROVIDER;
+
+	constructor() {
+	}
+
+	dispose() {
+	}
+
+	compute(cancelationToken: CancellationToken): Promise<FoldingRegions> {
+		return Promise.resolve(new FoldingRegions(new Uint32Array(0), new Uint32Array(0)));
+	}
+}
diff --git a/src/vs/editor/contrib/folding/browser/syntaxRangeProvider.ts b/src/vs/editor/contrib/folding/browser/syntaxRangeProvider.ts
index f1c58f8..8f00ded 100644
--- a/src/vs/editor/contrib/folding/browser/syntaxRangeProvider.ts
+++ b/src/vs/editor/contrib/folding/browser/syntaxRangeProvider.ts
@@ -26,7 +26,7 @@ export class SyntaxRangeProvider implements RangeProvider {
 
 	readonly disposables: DisposableStore | undefined;
 
-	constructor(private readonly editorModel: ITextModel, private providers: FoldingRangeProvider[], handleFoldingRangesChange: () => void, private limit: number) {
+	constructor(private readonly editorModel: ITextModel, private providers: FoldingRangeProvider[], private showFoldingLastLine: boolean, handleFoldingRangesChange: () => void, private limit: number) {
 		for (const provider of providers) {
 			if (typeof provider.onDidChange === 'function') {
 				if (!this.disposables) {
@@ -38,7 +38,7 @@ export class SyntaxRangeProvider implements RangeProvider {
 	}
 
 	compute(cancellationToken: CancellationToken, notifyTooManyRegions?: (maxRegions: number) => void): Promise<FoldingRegions | null> {
-		return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {
+		return collectSyntaxRanges(this.providers, this.editorModel, this.showFoldingLastLine, cancellationToken).then(ranges => {
 			if (ranges) {
 				let res = sanitizeRanges(ranges, this.limit, notifyTooManyRegions);
 				return res;
@@ -52,7 +52,7 @@ export class SyntaxRangeProvider implements RangeProvider {
 	}
 }
 
-function collectSyntaxRanges(providers: FoldingRangeProvider[], model: ITextModel, cancellationToken: CancellationToken): Promise<IFoldingRangeData[] | null> {
+function collectSyntaxRanges(providers: FoldingRangeProvider[], model: ITextModel, showFoldingLastLine: boolean, cancellationToken: CancellationToken): Promise<IFoldingRangeData[] | null> {
 	let rangeData: IFoldingRangeData[] | null = null;
 	let promises = providers.map((provider, i) => {
 		return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {
@@ -63,10 +63,23 @@ function collectSyntaxRanges(providers: FoldingRangeProvider[], model: ITextMode
 				if (!Array.isArray(rangeData)) {
 					rangeData = [];
 				}
+
 				let nLines = model.getLineCount();
-				for (let r of ranges) {
-					if (r.start > 0 && r.end > r.start && r.end <= nLines) {
-						rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
+				if (provider.isManagingLastLine || showFoldingLastLine) {
+					for (let r of ranges) {
+						if (r.start > 0 && r.end > r.start && r.end <= nLines) {
+							rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
+						}
+					}
+				} else {
+					for (let r of ranges) {
+						if (r.start > 0 && r.end >= r.start && r.end <= nLines) {
+							if (r.end === nLines) {
+								rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
+							} else {
+								rangeData.push({ start: r.start, end: r.end + 1, rank: i, kind: r.kind });
+							}
+						}
 					}
 				}
 			}
diff --git a/src/vs/editor/contrib/folding/test/browser/foldingModel.test.ts b/src/vs/editor/contrib/folding/test/browser/foldingModel.test.ts
index 6b54319..14c3210 100644
--- a/src/vs/editor/contrib/folding/test/browser/foldingModel.test.ts
+++ b/src/vs/editor/contrib/folding/test/browser/foldingModel.test.ts
@@ -145,7 +145,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -184,7 +184,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -230,7 +230,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -242,7 +242,7 @@ suite('Folding Model', () => {
 
 			textModel.applyEdits([EditOperation.insert(new Position(4, 1), '//hello\n')]);
 
-			foldingModel.update(computeRanges(textModel, false, undefined));
+			foldingModel.update(computeRanges(textModel, false, undefined).toFoldingRegions(textModel));
 
 			assertRanges(foldingModel, [r(1, 3, true), r(5, 8, false), r(6, 7, true)]);
 		} finally {
@@ -270,7 +270,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 12, false);
@@ -284,7 +284,7 @@ suite('Folding Model', () => {
 
 			textModel.applyEdits([EditOperation.delete(new Range(6, 11, 9, 0))]);
 
-			foldingModel.update(computeRanges(textModel, false, undefined));
+			foldingModel.update(computeRanges(textModel, false, undefined).toFoldingRegions(textModel));
 
 			assertRanges(foldingModel, [r(1, 9, false), r(2, 8, false), r(3, 5, false), r(6, 8, false)]);
 		} finally {
@@ -307,7 +307,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -349,7 +349,7 @@ suite('Folding Model', () => {
 
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -399,7 +399,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 10, false);
@@ -445,7 +445,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -501,7 +501,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\s*\/\/#region$/, end: /^\s*\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\s*\/\/#region$/, end: /^\s*\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -557,7 +557,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -609,7 +609,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -656,7 +656,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -701,7 +701,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 3, false);
@@ -741,7 +741,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ });
+			let ranges = computeRanges(textModel, false, { start: /^\/\/#region$/, end: /^\/\/#endregion$/ }).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 2, false);
@@ -784,7 +784,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 6, false);
@@ -852,7 +852,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(1, 12, false);
@@ -909,7 +909,7 @@ suite('Folding Model', () => {
 		try {
 			let foldingModel = new FoldingModel(textModel, new TestDecorationProvider(textModel));
 
-			let ranges = computeRanges(textModel, false, undefined);
+			let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 			foldingModel.update(ranges);
 
 			let r1 = r(2, 3, false);
diff --git a/src/vs/editor/contrib/folding/test/browser/foldingRanges.test.ts b/src/vs/editor/contrib/folding/test/browser/foldingRanges.test.ts
index a5011b0..db22e18 100644
--- a/src/vs/editor/contrib/folding/test/browser/foldingRanges.test.ts
+++ b/src/vs/editor/contrib/folding/test/browser/foldingRanges.test.ts
@@ -27,7 +27,7 @@ suite('FoldingRanges', () => {
 			lines.push('#endregion');
 		}
 		let model = createTextModel(lines.join('\n'));
-		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS);
+		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS).toFoldingRegions(model);
 		assert.strictEqual(actual.length, nRegions, 'len');
 		for (let i = 0; i < nRegions; i++) {
 			assert.strictEqual(actual.getStartLineNumber(i), i + 1, 'start' + i);
@@ -56,7 +56,7 @@ suite('FoldingRanges', () => {
 
 		let textModel = createTextModel(lines.join('\n'));
 		try {
-			let actual = computeRanges(textModel, false, markers);
+			let actual = computeRanges(textModel, false, markers).toFoldingRegions(textModel);
 			// let r0 = r(1, 2);
 			// let r1 = r(3, 12);
 			// let r2 = r(4, 11);
@@ -93,7 +93,7 @@ suite('FoldingRanges', () => {
 			lines.push('#endregion');
 		}
 		let model = createTextModel(lines.join('\n'));
-		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS);
+		let actual = computeRanges(model, false, markers, MAX_FOLDING_REGIONS).toFoldingRegions(model);
 		assert.strictEqual(actual.length, nRegions, 'len');
 		for (let i = 0; i < nRegions; i++) {
 			actual.setCollapsed(i, i % 3 === 0);
diff --git a/src/vs/editor/contrib/folding/test/browser/hiddenRangeModel.test.ts b/src/vs/editor/contrib/folding/test/browser/hiddenRangeModel.test.ts
index 661fecb..0490941 100644
--- a/src/vs/editor/contrib/folding/test/browser/hiddenRangeModel.test.ts
+++ b/src/vs/editor/contrib/folding/test/browser/hiddenRangeModel.test.ts
@@ -44,7 +44,7 @@ suite('Hidden Range Model', () => {
 
 		assert.strictEqual(hiddenRangeModel.hasRanges(), false);
 
-		let ranges = computeRanges(textModel, false, undefined);
+		let ranges = computeRanges(textModel, false, undefined).toFoldingRegions(textModel);
 		foldingModel.update(ranges);
 
 		foldingModel.toggleCollapseState([foldingModel.getRegionAtLine(1)!, foldingModel.getRegionAtLine(6)!]);
diff --git a/src/vs/editor/contrib/folding/test/browser/indentFold.test.ts b/src/vs/editor/contrib/folding/test/browser/indentFold.test.ts
index 41fe83e..b4e4f24 100644
--- a/src/vs/editor/contrib/folding/test/browser/indentFold.test.ts
+++ b/src/vs/editor/contrib/folding/test/browser/indentFold.test.ts
@@ -50,7 +50,7 @@ suite('Indentation Folding', () => {
 		let model = createTextModel(lines.join('\n'));
 
 		function assertLimit(maxEntries: number, expectedRanges: IndentRange[], message: string) {
-			let indentRanges = computeRanges(model, true, undefined, maxEntries);
+			let indentRanges = computeRanges(model, true, undefined, maxEntries).toFoldingRegions(model);
 			assert.ok(indentRanges.length <= maxEntries, 'max ' + message);
 			let actual: IndentRange[] = [];
 			for (let i = 0; i < indentRanges.length; i++) {
diff --git a/src/vs/editor/contrib/folding/test/browser/indentRangeProvider.test.ts b/src/vs/editor/contrib/folding/test/browser/indentRangeProvider.test.ts
index 03224a1..ed5f043 100644
--- a/src/vs/editor/contrib/folding/test/browser/indentRangeProvider.test.ts
+++ b/src/vs/editor/contrib/folding/test/browser/indentRangeProvider.test.ts
@@ -16,7 +16,7 @@ interface ExpectedIndentRange {
 
 function assertRanges(lines: string[], expected: ExpectedIndentRange[], offside: boolean, markers?: FoldingMarkers): void {
 	let model = createTextModel(lines.join('\n'));
-	let actual = computeRanges(model, offside, markers);
+	let actual = computeRanges(model, offside, markers).toFoldingRegions(model);
 
 	let actualRanges: ExpectedIndentRange[] = [];
 	for (let i = 0; i < actual.length; i++) {
diff --git a/src/vs/editor/contrib/folding/test/browser/syntaxFold.test.ts b/src/vs/editor/contrib/folding/test/browser/syntaxFold.test.ts
index 78ba186..fc7ea50 100644
--- a/src/vs/editor/contrib/folding/test/browser/syntaxFold.test.ts
+++ b/src/vs/editor/contrib/folding/test/browser/syntaxFold.test.ts
@@ -74,7 +74,7 @@ suite('Syntax folding', () => {
 		let providers = [new TestFoldingRangeProvider(model, ranges)];
 
 		async function assertLimit(maxEntries: number, expectedRanges: IndentRange[], message: string) {
-			let indentRanges = await new SyntaxRangeProvider(model, providers, () => { }, maxEntries).compute(CancellationToken.None);
+			let indentRanges = await new SyntaxRangeProvider(model, providers, true, () => { }, maxEntries).compute(CancellationToken.None);
 			let actual: IndentRange[] = [];
 			if (indentRanges) {
 				for (let i = 0; i < indentRanges.length; i++) {
diff --git a/src/vs/monaco.d.ts b/src/vs/monaco.d.ts
index 52e3225..5160769 100644
--- a/src/vs/monaco.d.ts
+++ b/src/vs/monaco.d.ts
@@ -3230,7 +3230,7 @@ declare namespace monaco.editor {
 		 * Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
 		 * Defaults to 'auto'.
 		 */
-		foldingStrategy?: 'auto' | 'indentation';
+		foldingStrategy?: string;
 		/**
 		 * Enable highlight for folded regions.
 		 * Defaults to true.
@@ -3251,6 +3251,11 @@ declare namespace monaco.editor {
 		 * Defaults to 'mouseover'.
 		 */
 		showFoldingControls?: 'always' | 'mouseover';
+		/**
+		 * Show the last line of the folding range.
+		 * Defaults to true.
+		 */
+		showFoldingLastLine?: boolean;
 		/**
 		 * Controls whether clicking on the empty content after a folded line will unfold the line.
 		 * Defaults to false.
@@ -4270,39 +4275,40 @@ declare namespace monaco.editor {
 		selectionHighlight = 97,
 		selectOnLineNumbers = 98,
 		showFoldingControls = 99,
-		showUnused = 100,
-		snippetSuggestions = 101,
-		smartSelect = 102,
-		smoothScrolling = 103,
-		stickyTabStops = 104,
-		stopRenderingLineAfter = 105,
-		suggest = 106,
-		suggestFontSize = 107,
-		suggestLineHeight = 108,
-		suggestOnTriggerCharacters = 109,
-		suggestSelection = 110,
-		tabCompletion = 111,
-		tabIndex = 112,
-		unicodeHighlighting = 113,
-		unusualLineTerminators = 114,
-		useShadowDOM = 115,
-		useTabStops = 116,
-		wordSeparators = 117,
-		wordWrap = 118,
-		wordWrapBreakAfterCharacters = 119,
-		wordWrapBreakBeforeCharacters = 120,
-		wordWrapColumn = 121,
-		wordWrapOverride1 = 122,
-		wordWrapOverride2 = 123,
-		wrappingIndent = 124,
-		wrappingStrategy = 125,
-		showDeprecated = 126,
-		inlayHints = 127,
-		editorClassName = 128,
-		pixelRatio = 129,
-		tabFocusMode = 130,
-		layoutInfo = 131,
-		wrappingInfo = 132
+		showFoldingLastLine = 100,
+		showUnused = 101,
+		snippetSuggestions = 102,
+		smartSelect = 103,
+		smoothScrolling = 104,
+		stickyTabStops = 105,
+		stopRenderingLineAfter = 106,
+		suggest = 107,
+		suggestFontSize = 108,
+		suggestLineHeight = 109,
+		suggestOnTriggerCharacters = 110,
+		suggestSelection = 111,
+		tabCompletion = 112,
+		tabIndex = 113,
+		unicodeHighlighting = 114,
+		unusualLineTerminators = 115,
+		useShadowDOM = 116,
+		useTabStops = 117,
+		wordSeparators = 118,
+		wordWrap = 119,
+		wordWrapBreakAfterCharacters = 120,
+		wordWrapBreakBeforeCharacters = 121,
+		wordWrapColumn = 122,
+		wordWrapOverride1 = 123,
+		wordWrapOverride2 = 124,
+		wrappingIndent = 125,
+		wrappingStrategy = 126,
+		showDeprecated = 127,
+		inlayHints = 128,
+		editorClassName = 129,
+		pixelRatio = 130,
+		tabFocusMode = 131,
+		layoutInfo = 132,
+		wrappingInfo = 133
 	}
 
 	export const EditorOptions: {
@@ -4345,7 +4351,7 @@ declare namespace monaco.editor {
 		find: IEditorOption<EditorOption.find, Readonly<Required<IEditorFindOptions>>>;
 		fixedOverflowWidgets: IEditorOption<EditorOption.fixedOverflowWidgets, boolean>;
 		folding: IEditorOption<EditorOption.folding, boolean>;
-		foldingStrategy: IEditorOption<EditorOption.foldingStrategy, 'auto' | 'indentation'>;
+		foldingStrategy: IEditorOption<EditorOption.foldingStrategy, string>;
 		foldingHighlight: IEditorOption<EditorOption.foldingHighlight, boolean>;
 		foldingImportsByDefault: IEditorOption<EditorOption.foldingImportsByDefault, boolean>;
 		foldingMaximumRegions: IEditorOption<EditorOption.foldingMaximumRegions, number>;
@@ -4406,6 +4412,7 @@ declare namespace monaco.editor {
 		selectionHighlight: IEditorOption<EditorOption.selectionHighlight, boolean>;
 		selectOnLineNumbers: IEditorOption<EditorOption.selectOnLineNumbers, boolean>;
 		showFoldingControls: IEditorOption<EditorOption.showFoldingControls, 'always' | 'mouseover'>;
+		showFoldingLastLine: IEditorOption<EditorOption.showFoldingLastLine, boolean>;
 		showUnused: IEditorOption<EditorOption.showUnused, boolean>;
 		showDeprecated: IEditorOption<EditorOption.showDeprecated, boolean>;
 		inlayHints: IEditorOption<EditorOption.inlayHints, Readonly<Required<IEditorInlayHintsOptions>>>;
@@ -6756,6 +6763,14 @@ declare namespace monaco.languages {
 	 * A provider of folding ranges for editor models.
 	 */
 	export interface FoldingRangeProvider {
+		/**
+		 * Provides the id of the provider.
+		 */
+		readonly id?: string;
+		/**
+		 * Flag if the provider is managing the folding range's last line
+		 */
+		readonly isManagingLastLine?: boolean;
 		/**
 		 * An optional event to signal that the folding ranges from this provider have changed.
 		 */
diff --git a/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts b/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts
index e098e7a..3a2a264 100644
--- a/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts
+++ b/src/vs/workbench/api/browser/mainThreadLanguageFeatures.ts
@@ -676,8 +676,10 @@ export class MainThreadLanguageFeatures implements MainThreadLanguageFeaturesSha
 
 	// --- folding
 
-	$registerFoldingRangeProvider(handle: number, selector: IDocumentFilterDto[], eventHandle: number | undefined): void {
+	$registerFoldingRangeProvider(handle: number, id: string | null, isManagingLastLine: boolean, selector: IDocumentFilterDto[], eventHandle: number | undefined): void {
 		const provider = <modes.FoldingRangeProvider>{
+			id,
+			isManagingLastLine,
 			provideFoldingRanges: (model, context, token) => {
 				return this._proxy.$provideFoldingRanges(handle, model.uri, context, token);
 			}
diff --git a/src/vs/workbench/api/common/extHost.protocol.ts b/src/vs/workbench/api/common/extHost.protocol.ts
index 1f8a3c5..98b2e8d 100644
--- a/src/vs/workbench/api/common/extHost.protocol.ts
+++ b/src/vs/workbench/api/common/extHost.protocol.ts
@@ -445,7 +445,7 @@ export interface MainThreadLanguageFeaturesShape extends IDisposable {
 	$emitInlayHintsEvent(eventHandle: number): void;
 	$registerDocumentLinkProvider(handle: number, selector: IDocumentFilterDto[], supportsResolve: boolean): void;
 	$registerDocumentColorProvider(handle: number, selector: IDocumentFilterDto[]): void;
-	$registerFoldingRangeProvider(handle: number, selector: IDocumentFilterDto[], eventHandle: number | undefined): void;
+	$registerFoldingRangeProvider(handle: number, id: string | null, isManagingLastLine: boolean, selector: IDocumentFilterDto[], eventHandle: number | undefined): void;
 	$emitFoldingRangeEvent(eventHandle: number, event?: any): void;
 	$registerSelectionRangeProvider(handle: number, selector: IDocumentFilterDto[]): void;
 	$registerCallHierarchyProvider(handle: number, selector: IDocumentFilterDto[]): void;
diff --git a/src/vs/workbench/api/common/extHostLanguageFeatures.ts b/src/vs/workbench/api/common/extHostLanguageFeatures.ts
index 5725608..bcd9b27 100644
--- a/src/vs/workbench/api/common/extHostLanguageFeatures.ts
+++ b/src/vs/workbench/api/common/extHostLanguageFeatures.ts
@@ -2147,7 +2147,7 @@ export class ExtHostLanguageFeatures implements extHostProtocol.ExtHostLanguageF
 		const eventHandle = typeof provider.onDidChangeFoldingRanges === 'function' ? this._nextHandle() : undefined;
 
 		this._adapter.set(handle, new AdapterData(new FoldingProviderAdapter(this._documents, provider), extension));
-		this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector), eventHandle);
+		this._proxy.$registerFoldingRangeProvider(handle, provider.id ?? null, provider.isManagingLastLine ?? false, this._transformDocumentSelector(selector), eventHandle);
 		let result = this._createDisposable(handle);
 
 		if (eventHandle !== undefined) {
diff --git a/src/vscode-dts/vscode.d.ts b/src/vscode-dts/vscode.d.ts
index 6ad7951..97e6791 100644
--- a/src/vscode-dts/vscode.d.ts
+++ b/src/vscode-dts/vscode.d.ts
@@ -4637,6 +4637,16 @@ declare module 'vscode' {
 	 */
 	export interface FoldingRangeProvider {
 
+		/**
+		 * Provides the id of the provider.
+		 */
+		readonly id?: string;
+
+		/**
+		 * Flag if the provider is managing the folding range's last line
+		 */
+		readonly isManagingLastLine?: boolean;
+
 		/**
 		 * An optional event to signal that the folding ranges from this provider have changed.
 		 */
